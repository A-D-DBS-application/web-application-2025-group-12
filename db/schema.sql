-- =========================================
-- Project: Grondmatching â€“ database volgens huidig schema
-- Doel: tabellen + constraints + indexes
-- DB: PostgreSQL (Supabase)
-- =========================================
 
BEGIN;
 
-- =========================================
-- ENUM: match_status
-- =========================================
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_type WHERE typname = 'match_status'
  ) THEN
    CREATE TYPE match_status AS ENUM ('pending', 'approved', 'accepted', 'rejected');
  END IF;
END$$;
 
-- =========================================
-- 1) COMPANY
-- =========================================
CREATE TABLE IF NOT EXISTS public.company (
  id     INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name   VARCHAR(200) NOT NULL UNIQUE,
  email  VARCHAR(320)
);
 
-- =========================================
-- 2) CLIENT
-- =========================================
CREATE TABLE IF NOT EXISTS public.client (
  id         INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  company_id INT REFERENCES public.company(id) ON DELETE SET NULL,
  name       VARCHAR(200) NOT NULL,
  email      VARCHAR(320) NOT NULL UNIQUE,
  address    VARCHAR(300) NOT NULL
);
 
CREATE INDEX IF NOT EXISTS idx_client_company_id ON public.client(company_id);
 
-- =========================================
-- 3) GROUND
-- =========================================
CREATE TABLE IF NOT EXISTS public.ground (
  id               INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  location         VARCHAR(200) NOT NULL,
  address          VARCHAR(300),
  m2               INT NOT NULL CHECK (m2 >= 0),
  budget           NUMERIC NOT NULL CHECK (budget >= 0),
  subdivision_type VARCHAR(120) NOT NULL,
  owner            VARCHAR(200) NOT NULL,
  provider         VARCHAR(200),
  image_url        TEXT,
  photo_url        TEXT
);
 
CREATE INDEX IF NOT EXISTS idx_ground_location ON public.ground(location);
CREATE INDEX IF NOT EXISTS idx_ground_budget   ON public.ground(budget);
CREATE INDEX IF NOT EXISTS idx_ground_m2       ON public.ground(m2);
CREATE INDEX IF NOT EXISTS idx_ground_provider ON public.ground(provider);
 
-- =========================================
-- 4) PREFERENCES
-- =========================================
CREATE TABLE IF NOT EXISTS public.preferences (
  id               INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  client_id        INT NOT NULL REFERENCES public.client(id) ON DELETE CASCADE,
  location         VARCHAR(200),
  subdivision_type VARCHAR(120),
  min_m2           INT CHECK (min_m2 IS NULL OR min_m2 >= 0),
  max_m2           INT CHECK (max_m2 IS NULL OR max_m2 >= 0),
  min_budget       NUMERIC CHECK (min_budget IS NULL OR min_budget >= 0),
  max_budget       NUMERIC CHECK (max_budget IS NULL OR max_budget >= 0),
  CONSTRAINT chk_m2_range
      CHECK (min_m2 IS NULL OR max_m2 IS NULL OR min_m2 <= max_m2),
  CONSTRAINT chk_budget_range
      CHECK (min_budget IS NULL OR max_budget IS NULL OR min_budget <= max_budget)
);
 
CREATE INDEX IF NOT EXISTS idx_preferences_client_id ON public.preferences(client_id);
 
-- =========================================
-- 5) MATCH
-- =========================================
CREATE TABLE IF NOT EXISTS public.match (
  id             INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ground_id      INT NOT NULL REFERENCES public.ground(id) ON DELETE CASCADE,
  m2_score       NUMERIC NOT NULL DEFAULT 0 CHECK (m2_score >= 0),
  budget_score   NUMERIC NOT NULL DEFAULT 0 CHECK (budget_score >= 0),
  location_score NUMERIC NOT NULL DEFAULT 0 CHECK (location_score >= 0),
  type_score     NUMERIC NOT NULL DEFAULT 0 CHECK (type_score >= 0),
  status         match_status NOT NULL DEFAULT 'pending',
  client_id      INT NOT NULL REFERENCES public.client(id) ON DELETE CASCADE,
  CONSTRAINT uq_match_unique_pair UNIQUE (client_id, ground_id)
);
 
CREATE INDEX IF NOT EXISTS idx_match_client_id ON public.match(client_id);
CREATE INDEX IF NOT EXISTS idx_match_ground_id ON public.match(ground_id);
CREATE INDEX IF NOT EXISTS idx_match_status    ON public.match(status);
 
COMMIT;