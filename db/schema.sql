-- =========================================
-- Project: Grondmatching – basis-ERD
-- Doel: tabellen + constraints + indexen
-- DB: PostgreSQL (Supabase)
-- =========================================

-- Optioneel: alles in één transactie
BEGIN;

-- Handige enum voor match-status (optioneel maar netjes)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'match_status') THEN
    CREATE TYPE match_status AS ENUM ('pending', 'accepted', 'rejected');
  END IF;
END$$;

-- ======================
-- 1) COMPANY
-- ======================x
CREATE TABLE IF NOT EXISTS public.company (
  id     INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name   VARCHAR(200) NOT NULL UNIQUE,
  email  VARCHAR(320)
);

-- ======================
-- 2) CLIENT
-- ======================
CREATE TABLE IF NOT EXISTS public.client (
  id         INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  company_id INT REFERENCES public.company(id) ON DELETE SET NULL,
  name       VARCHAR(200) NOT NULL,
  email      VARCHAR(320) NOT NULL,
  address    VARCHAR(300) NOT NULL,
  CONSTRAINT uq_client_email UNIQUE (email)
);

-- Index voor lookups per company
CREATE INDEX IF NOT EXISTS idx_client_company_id ON public.client(company_id);

-- ======================
-- 3) GROUND
-- ======================
CREATE TABLE IF NOT EXISTS public.ground (
  id               INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  soil             VARCHAR(100) NOT NULL,
  location         VARCHAR(200) NOT NULL,
  m2               INT NOT NULL CHECK (m2 >= 0),
  budget           NUMERIC(12,2) NOT NULL CHECK (budget >= 0),
  subdivision_type VARCHAR(120) NOT NULL,
  owner            VARCHAR(200) NOT NULL
);

-- Snelle filters
CREATE INDEX IF NOT EXISTS idx_ground_location ON public.ground(location);
CREATE INDEX IF NOT EXISTS idx_ground_budget ON public.ground(budget);
CREATE INDEX IF NOT EXISTS idx_ground_m2 ON public.ground(m2);

-- ======================
-- 4) PREFERENCES
-- ======================
CREATE TABLE IF NOT EXISTS public.preferences (
  id               INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  client_id        INT NOT NULL REFERENCES public.client(id) ON DELETE CASCADE,
  soil             VARCHAR(100),
  location         VARCHAR(200),
  subdivision_type VARCHAR(120),
  min_m2           INT CHECK (min_m2 IS NULL OR min_m2 >= 0),
  max_m2           INT CHECK (max_m2 IS NULL OR max_m2 >= 0),
  min_budget       NUMERIC(12,2) CHECK (min_budget IS NULL OR min_budget >= 0),
  max_budget       NUMERIC(12,2) CHECK (max_budget IS NULL OR max_budget >= 0),
  -- logische grenzen als beide kanten zijn ingevuld
  CONSTRAINT chk_m2_range     CHECK (min_m2     IS NULL OR max_m2     IS NULL OR min_m2     <= max_m2),
  CONSTRAINT chk_budget_range CHECK (min_budget IS NULL OR max_budget IS NULL OR min_budget <= max_budget)
);

CREATE INDEX IF NOT EXISTS idx_preferences_client_id ON public.preferences(client_id);

-- ======================
-- 5) MATCH
-- ======================
CREATE TABLE IF NOT EXISTS public.match (
  id             INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  company_id     INT NOT NULL REFERENCES public.company(id)     ON DELETE CASCADE,
  ground_id      INT NOT NULL REFERENCES public.ground(id)      ON DELETE CASCADE,
  preferences_id INT NOT NULL REFERENCES public.preferences(id) ON DELETE CASCADE,
  m2_score       NUMERIC(5,2)  NOT NULL DEFAULT 0 CHECK (m2_score      >= 0),
  budget_score   NUMERIC(5,2)  NOT NULL DEFAULT 0 CHECK (budget_score  >= 0),
  status         match_status  NOT NULL DEFAULT 'pending',
  -- één en dezelfde combinatie niet twee keer
  CONSTRAINT uq_match_triplet UNIQUE (company_id, ground_id, preferences_id)
);

CREATE INDEX IF NOT EXISTS idx_match_company   ON public.match(company_id);
CREATE INDEX IF NOT EXISTS idx_match_ground    ON public.match(ground_id);
CREATE INDEX IF NOT EXISTS idx_match_pref      ON public.match(preferences_id);
CREATE INDEX IF NOT EXISTS idx_match_status    ON public.match(status);

COMMIT;

-- Klaar. (Als je RLS gaat gebruiken in Supabase, zet policies pas hierna op.)
